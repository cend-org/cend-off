// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/cend-org/duval/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Asset struct {
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Authorization struct {
		AccessLevel func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DeletedAt   func(childComplexity int) int
		ID          func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserID      func(childComplexity int) int
	}

	Mutation struct {
		DelPassword       func(childComplexity int, id int) int
		LogIn             func(childComplexity int, email string, password string) int
		NewAsset          func(childComplexity int, asset model.AssetInput) int
		NewPassword       func(childComplexity int, password string) int
		PopulateSchool    func(childComplexity int) int
		Register          func(childComplexity int, input model.UserInput) int
		RegisterWithEmail func(childComplexity int, input string, as int) int
	}

	Password struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Hash      func(childComplexity int) int
		ID        func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		UserID    func(childComplexity int) int
	}

	Query struct {
		Assets      func(childComplexity int) int
		GetAsset    func(childComplexity int, id int) int
		GetSchool   func(childComplexity int, id int) int
		GetSchools  func(childComplexity int) int
		GetSubjects func(childComplexity int, id int) int
		MyProfile   func(childComplexity int) int
		Passwords   func(childComplexity int) int
		Users       func(childComplexity int) int
	}

	School struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}

	SchoolSubject struct {
		CreatedAt    func(childComplexity int) int
		DeletedAt    func(childComplexity int) int
		ID           func(childComplexity int) int
		Name         func(childComplexity int) int
		SchoolNumber func(childComplexity int) int
		UpdatedAt    func(childComplexity int) int
	}

	User struct {
		CreatedAt func(childComplexity int) int
		DeletedAt func(childComplexity int) int
		Email     func(childComplexity int) int
		ID        func(childComplexity int) int
		LastName  func(childComplexity int) int
		Name      func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Asset.CreatedAt":
		if e.complexity.Asset.CreatedAt == nil {
			break
		}

		return e.complexity.Asset.CreatedAt(childComplexity), true

	case "Asset.DeletedAt":
		if e.complexity.Asset.DeletedAt == nil {
			break
		}

		return e.complexity.Asset.DeletedAt(childComplexity), true

	case "Asset.Description":
		if e.complexity.Asset.Description == nil {
			break
		}

		return e.complexity.Asset.Description(childComplexity), true

	case "Asset.Id":
		if e.complexity.Asset.ID == nil {
			break
		}

		return e.complexity.Asset.ID(childComplexity), true

	case "Asset.UpdatedAt":
		if e.complexity.Asset.UpdatedAt == nil {
			break
		}

		return e.complexity.Asset.UpdatedAt(childComplexity), true

	case "Authorization.AccessLevel":
		if e.complexity.Authorization.AccessLevel == nil {
			break
		}

		return e.complexity.Authorization.AccessLevel(childComplexity), true

	case "Authorization.createdAt":
		if e.complexity.Authorization.CreatedAt == nil {
			break
		}

		return e.complexity.Authorization.CreatedAt(childComplexity), true

	case "Authorization.deletedAt":
		if e.complexity.Authorization.DeletedAt == nil {
			break
		}

		return e.complexity.Authorization.DeletedAt(childComplexity), true

	case "Authorization.id":
		if e.complexity.Authorization.ID == nil {
			break
		}

		return e.complexity.Authorization.ID(childComplexity), true

	case "Authorization.updatedAt":
		if e.complexity.Authorization.UpdatedAt == nil {
			break
		}

		return e.complexity.Authorization.UpdatedAt(childComplexity), true

	case "Authorization.userId":
		if e.complexity.Authorization.UserID == nil {
			break
		}

		return e.complexity.Authorization.UserID(childComplexity), true

	case "Mutation.DelPassword":
		if e.complexity.Mutation.DelPassword == nil {
			break
		}

		args, err := ec.field_Mutation_DelPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DelPassword(childComplexity, args["id"].(int)), true

	case "Mutation.LogIn":
		if e.complexity.Mutation.LogIn == nil {
			break
		}

		args, err := ec.field_Mutation_LogIn_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.LogIn(childComplexity, args["email"].(string), args["password"].(string)), true

	case "Mutation.NewAsset":
		if e.complexity.Mutation.NewAsset == nil {
			break
		}

		args, err := ec.field_Mutation_NewAsset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewAsset(childComplexity, args["asset"].(model.AssetInput)), true

	case "Mutation.NewPassword":
		if e.complexity.Mutation.NewPassword == nil {
			break
		}

		args, err := ec.field_Mutation_NewPassword_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.NewPassword(childComplexity, args["password"].(string)), true

	case "Mutation.PopulateSchool":
		if e.complexity.Mutation.PopulateSchool == nil {
			break
		}

		return e.complexity.Mutation.PopulateSchool(childComplexity), true

	case "Mutation.Register":
		if e.complexity.Mutation.Register == nil {
			break
		}

		args, err := ec.field_Mutation_Register_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Register(childComplexity, args["input"].(model.UserInput)), true

	case "Mutation.RegisterWithEmail":
		if e.complexity.Mutation.RegisterWithEmail == nil {
			break
		}

		args, err := ec.field_Mutation_RegisterWithEmail_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.RegisterWithEmail(childComplexity, args["input"].(string), args["as"].(int)), true

	case "Password.CreatedAt":
		if e.complexity.Password.CreatedAt == nil {
			break
		}

		return e.complexity.Password.CreatedAt(childComplexity), true

	case "Password.DeletedAt":
		if e.complexity.Password.DeletedAt == nil {
			break
		}

		return e.complexity.Password.DeletedAt(childComplexity), true

	case "Password.Hash":
		if e.complexity.Password.Hash == nil {
			break
		}

		return e.complexity.Password.Hash(childComplexity), true

	case "Password.Id":
		if e.complexity.Password.ID == nil {
			break
		}

		return e.complexity.Password.ID(childComplexity), true

	case "Password.UpdatedAt":
		if e.complexity.Password.UpdatedAt == nil {
			break
		}

		return e.complexity.Password.UpdatedAt(childComplexity), true

	case "Password.UserId":
		if e.complexity.Password.UserID == nil {
			break
		}

		return e.complexity.Password.UserID(childComplexity), true

	case "Query.Assets":
		if e.complexity.Query.Assets == nil {
			break
		}

		return e.complexity.Query.Assets(childComplexity), true

	case "Query.GetAsset":
		if e.complexity.Query.GetAsset == nil {
			break
		}

		args, err := ec.field_Query_GetAsset_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetAsset(childComplexity, args["id"].(int)), true

	case "Query.getSchool":
		if e.complexity.Query.GetSchool == nil {
			break
		}

		args, err := ec.field_Query_getSchool_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSchool(childComplexity, args["id"].(int)), true

	case "Query.getSchools":
		if e.complexity.Query.GetSchools == nil {
			break
		}

		return e.complexity.Query.GetSchools(childComplexity), true

	case "Query.getSubjects":
		if e.complexity.Query.GetSubjects == nil {
			break
		}

		args, err := ec.field_Query_getSubjects_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetSubjects(childComplexity, args["id"].(int)), true

	case "Query.MyProfile":
		if e.complexity.Query.MyProfile == nil {
			break
		}

		return e.complexity.Query.MyProfile(childComplexity), true

	case "Query.Passwords":
		if e.complexity.Query.Passwords == nil {
			break
		}

		return e.complexity.Query.Passwords(childComplexity), true

	case "Query.Users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "School.CreatedAt":
		if e.complexity.School.CreatedAt == nil {
			break
		}

		return e.complexity.School.CreatedAt(childComplexity), true

	case "School.DeletedAt":
		if e.complexity.School.DeletedAt == nil {
			break
		}

		return e.complexity.School.DeletedAt(childComplexity), true

	case "School.Id":
		if e.complexity.School.ID == nil {
			break
		}

		return e.complexity.School.ID(childComplexity), true

	case "School.Name":
		if e.complexity.School.Name == nil {
			break
		}

		return e.complexity.School.Name(childComplexity), true

	case "School.UpdatedAt":
		if e.complexity.School.UpdatedAt == nil {
			break
		}

		return e.complexity.School.UpdatedAt(childComplexity), true

	case "SchoolSubject.CreatedAt":
		if e.complexity.SchoolSubject.CreatedAt == nil {
			break
		}

		return e.complexity.SchoolSubject.CreatedAt(childComplexity), true

	case "SchoolSubject.DeletedAt":
		if e.complexity.SchoolSubject.DeletedAt == nil {
			break
		}

		return e.complexity.SchoolSubject.DeletedAt(childComplexity), true

	case "SchoolSubject.Id":
		if e.complexity.SchoolSubject.ID == nil {
			break
		}

		return e.complexity.SchoolSubject.ID(childComplexity), true

	case "SchoolSubject.Name":
		if e.complexity.SchoolSubject.Name == nil {
			break
		}

		return e.complexity.SchoolSubject.Name(childComplexity), true

	case "SchoolSubject.SchoolNumber":
		if e.complexity.SchoolSubject.SchoolNumber == nil {
			break
		}

		return e.complexity.SchoolSubject.SchoolNumber(childComplexity), true

	case "SchoolSubject.UpdatedAt":
		if e.complexity.SchoolSubject.UpdatedAt == nil {
			break
		}

		return e.complexity.SchoolSubject.UpdatedAt(childComplexity), true

	case "User.CreatedAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.DeletedAt":
		if e.complexity.User.DeletedAt == nil {
			break
		}

		return e.complexity.User.DeletedAt(childComplexity), true

	case "User.Email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.Id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.LastName":
		if e.complexity.User.LastName == nil {
			break
		}

		return e.complexity.User.LastName(childComplexity), true

	case "User.Name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.UpdatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputAssetInput,
		ec.unmarshalInputPasswordInput,
		ec.unmarshalInputSchoolInput,
		ec.unmarshalInputSchoolSubjectInput,
		ec.unmarshalInputUserInput,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../gql/authorization/authorization.graphqls", Input: `type Authorization {
    id: ID!
    createdAt: DateTime!
    updatedAt: DateTime!
    deletedAt: DateTime
    userId: Int!
    AccessLevel: Int!
}`, BuiltIn: false},
	{Name: "../gql/directive/directive.graphqls", Input: `directive @goModel(
    model: String
    models: [String!]
    forceGenerate: Boolean
) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION


directive @goField(
    forceResolver: Boolean
    name: String
    omittable: Boolean
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION


directive @goTag(
    key: String!
    value: String
) on INPUT_FIELD_DEFINITION | FIELD_DEFINITION
`, BuiltIn: false},
	{Name: "../gql/password/password.graphqls", Input: `type Password {
    Id: ID!
    CreatedAt: DateTime!
    UpdatedAt: DateTime!
    DeletedAt: DateTime
    UserId: Int!
    Hash: String!
}

input PasswordInput{
    Hash: String
}`, BuiltIn: false},
	{Name: "../gql/scalar/scalar.graphqls", Input: `"The ` + "`" + `Date` + "`" + ` is a date in the format YYYY-MM-DD"
scalar Date

"The ` + "`" + `DateTime` + "`" + ` is a date in the format ISO 8601 format: ` + "`" + `2006-01-02T15:04:05Z07:00` + "`" + `"
scalar DateTime`, BuiltIn: false},
	{Name: "../gql/schema/mutation.graphqls", Input: `type Mutation {
    RegisterWithEmail(input: String!, as: Int!): String
    Register(input: UserInput!): Boolean

    LogIn(email: String!, password: String!): String

    NewPassword(password: String!): Boolean
    DelPassword(id: ID!): Boolean

    NewAsset(asset: AssetInput!): Asset

    PopulateSchool: Boolean
}
`, BuiltIn: false},
	{Name: "../gql/schema/query.graphqls", Input: `type Query {
    Passwords: [Password!]

    Users: [User!]!
    MyProfile: User!

    GetAsset(id: ID!): Asset
    Assets: [Asset!]

    getSchools: [School!]
    getSubjects(id: ID!): [SchoolSubject!]
    getSchool(id: ID!): School
}`, BuiltIn: false},
	{Name: "../gql/school/school.graphqls", Input: `type School {
    Id: ID!
    CreatedAt: DateTime!
    UpdatedAt: DateTime!
    DeletedAt: DateTime
    Name: String!
}

input SchoolInput {
    Name: String
}

type SchoolSubject {
    Id: ID!
    CreatedAt: DateTime!
    UpdatedAt: DateTime!
    DeletedAt: DateTime
    SchoolNumber: Int!
    Name: String!
}

input SchoolSubjectInput {
    SchoolNumber: Int
    Name: String
}`, BuiltIn: false},
	{Name: "../gql/user/user.graphqls", Input: `type User {
    Id: ID!
    CreatedAt: DateTime!
    UpdatedAt: DateTime!
    DeletedAt: DateTime
    Name: String!
    LastName: String!
    Email: String!
}

input UserInput {
    Name: String
    LastName: String
    Email: String
}`, BuiltIn: false},
	{Name: "../gql/utils/utils.graphqls", Input: `type Asset {
    Id: ID!
    CreatedAt: DateTime!
    UpdatedAt: DateTime!
    DeletedAt: DateTime
    Description: String!
}

input AssetInput {
    Description: String
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
